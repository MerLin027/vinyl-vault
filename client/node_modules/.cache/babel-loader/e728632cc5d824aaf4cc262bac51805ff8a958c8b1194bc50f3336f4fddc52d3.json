{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\VRUSHANK\\\\Desktop\\\\Ecom Website\\\\client\\\\src\\\\contexts\\\\SocketContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';\nimport io from 'socket.io-client';\nimport { useAuth } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SocketContext = /*#__PURE__*/createContext();\nexport function useSocket() {\n  _s();\n  return useContext(SocketContext);\n}\n_s(useSocket, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport function SocketProvider({\n  children\n}) {\n  _s2();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [roomUsers, setRoomUsers] = useState([]);\n  const [currentRoom, setCurrentRoom] = useState(null);\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\n  const [isReconnecting, setIsReconnecting] = useState(false);\n  const [typingUsers, setTypingUsers] = useState([]);\n  const [notifications, setNotifications] = useState([]);\n  const [messageStatus, setMessageStatus] = useState({});\n  const {\n    currentUser\n  } = useAuth();\n\n  // Keep a ref for timeout to clear typing status\n  const typingTimeoutRef = useRef(null);\n  const maxReconnectAttempts = 5;\n\n  // Create socket connection\n  const connectSocket = useCallback(() => {\n    if (!currentUser) return null;\n    const newSocket = io(process.env.REACT_APP_API_URL || 'http://localhost:5000', {\n      path: '/socket.io',\n      namespace: '/chat',\n      reconnection: true,\n      reconnectionAttempts: maxReconnectAttempts,\n      reconnectionDelay: 1000,\n      reconnectionDelayMax: 5000,\n      timeout: 10000\n    });\n    return newSocket;\n  }, [currentUser]);\n\n  // Handle reconnection logic\n  const attemptReconnect = useCallback(() => {\n    if (reconnectAttempts >= maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      setIsReconnecting(false);\n      return;\n    }\n    setIsReconnecting(true);\n    const newSocket = connectSocket();\n    if (newSocket) {\n      setSocket(newSocket);\n      setReconnectAttempts(prev => prev + 1);\n    }\n  }, [connectSocket, reconnectAttempts, maxReconnectAttempts]);\n\n  // Setup socket connection\n  useEffect(() => {\n    // Only connect if user is authenticated\n    if (currentUser) {\n      // Create socket connection\n      const newSocket = connectSocket();\n      if (!newSocket) return;\n\n      // Socket event listeners\n      newSocket.on('connect', () => {\n        console.log('Socket connected');\n        setIsConnected(true);\n        setIsReconnecting(false);\n        setReconnectAttempts(0);\n\n        // Rejoin room if was previously in one\n        if (currentRoom) {\n          newSocket.emit('join', {\n            roomId: currentRoom,\n            userId: currentUser.id,\n            username: currentUser.name || currentUser.email\n          });\n        }\n      });\n      newSocket.on('disconnect', () => {\n        console.log('Socket disconnected');\n        setIsConnected(false);\n        attemptReconnect();\n      });\n      newSocket.on('connect_error', error => {\n        console.error('Socket connection error:', error);\n        setIsConnected(false);\n        attemptReconnect();\n      });\n\n      // Event listeners for chat functionality\n      newSocket.on('message', messageData => {\n        console.log('Message received:', messageData);\n\n        // Add to notifications if not in current room\n        if (messageData.roomId !== currentRoom) {\n          setNotifications(prev => [...prev, {\n            id: Date.now(),\n            message: `New message from ${messageData.username} in room ${messageData.roomId}`,\n            roomId: messageData.roomId,\n            timestamp: new Date()\n          }]);\n        }\n\n        // Acknowledge message receipt\n        newSocket.emit('messageReceived', {\n          messageId: messageData.id,\n          roomId: messageData.roomId\n        });\n      });\n      newSocket.on('userJoined', data => {\n        console.log('User joined:', data);\n      });\n      newSocket.on('userLeft', data => {\n        console.log('User left:', data);\n      });\n      newSocket.on('roomUsers', data => {\n        console.log('Users in room:', data);\n        setRoomUsers(data.users);\n      });\n\n      // Typing indicator events\n      newSocket.on('userTyping', data => {\n        setTypingUsers(prev => {\n          if (!prev.some(user => user.id === data.userId)) {\n            return [...prev, {\n              id: data.userId,\n              username: data.username\n            }];\n          }\n          return prev;\n        });\n      });\n      newSocket.on('userStoppedTyping', data => {\n        setTypingUsers(prev => prev.filter(user => user.id !== data.userId));\n      });\n\n      // Message status updates\n      newSocket.on('messageDelivered', data => {\n        setMessageStatus(prev => ({\n          ...prev,\n          [data.messageId]: {\n            ...prev[data.messageId],\n            delivered: true,\n            deliveredAt: new Date()\n          }\n        }));\n      });\n      newSocket.on('messageRead', data => {\n        setMessageStatus(prev => ({\n          ...prev,\n          [data.messageId]: {\n            ...prev[data.messageId],\n            read: true,\n            readAt: new Date()\n          }\n        }));\n      });\n      setSocket(newSocket);\n\n      // Cleanup function\n      return () => {\n        if (currentRoom) {\n          newSocket.emit('leaveRoom', {\n            roomId: currentRoom\n          });\n        }\n\n        // Clear any existing timeouts\n        if (typingTimeoutRef.current) {\n          clearTimeout(typingTimeoutRef.current);\n        }\n        newSocket.close();\n      };\n    } else {\n      // If user logs out, disconnect socket\n      if (socket) {\n        if (currentRoom) {\n          socket.emit('leaveRoom', {\n            roomId: currentRoom\n          });\n        }\n        socket.close();\n        setSocket(null);\n        setIsConnected(false);\n        setCurrentRoom(null);\n        setRoomUsers([]);\n        setTypingUsers([]);\n        // Clear notifications and message status on logout\n        setNotifications([]);\n        setMessageStatus({});\n      }\n    }\n  }, [currentUser, connectSocket, attemptReconnect, currentRoom, socket]);\n\n  // Functions to emit events\n  const sendMessage = (roomId, message) => {\n    if (socket && isConnected && currentUser) {\n      const messageId = `${Date.now()}-${currentUser.id}`;\n      socket.emit('sendMessage', {\n        id: messageId,\n        roomId,\n        message,\n        userId: currentUser.id,\n        username: currentUser.name || currentUser.email\n      });\n\n      // Initialize message status\n      setMessageStatus(prev => ({\n        ...prev,\n        [messageId]: {\n          sent: true,\n          sentAt: new Date()\n        }\n      }));\n      return messageId;\n    }\n    return null;\n  };\n  const joinRoom = roomId => {\n    if (socket && isConnected && currentUser) {\n      // Leave current room if any\n      if (currentRoom && currentRoom !== roomId) {\n        socket.emit('leaveRoom', {\n          roomId: currentRoom\n        });\n      }\n\n      // Join new room\n      socket.emit('join', {\n        roomId,\n        userId: currentUser.id,\n        username: currentUser.name || currentUser.email\n      });\n      setCurrentRoom(roomId);\n\n      // Clear notifications for this room\n      setNotifications(prev => prev.filter(notif => notif.roomId !== roomId));\n      return true;\n    }\n    return false;\n  };\n  const leaveRoom = () => {\n    if (socket && isConnected && currentRoom) {\n      socket.emit('leaveRoom', {\n        roomId: currentRoom\n      });\n      setCurrentRoom(null);\n      setRoomUsers([]);\n      setTypingUsers([]);\n      return true;\n    }\n    return false;\n  };\n\n  // Typing indicator\n  const sendTypingStatus = isTyping => {\n    if (socket && isConnected && currentUser && currentRoom) {\n      if (isTyping) {\n        socket.emit('typing', {\n          roomId: currentRoom,\n          userId: currentUser.id,\n          username: currentUser.name || currentUser.email\n        });\n\n        // Clear existing timeout\n        if (typingTimeoutRef.current) {\n          clearTimeout(typingTimeoutRef.current);\n        }\n\n        // Set timeout to automatically stop typing status after 3 seconds\n        typingTimeoutRef.current = setTimeout(() => {\n          socket.emit('stopTyping', {\n            roomId: currentRoom,\n            userId: currentUser.id\n          });\n        }, 3000);\n      } else {\n        // Clear timeout if exists\n        if (typingTimeoutRef.current) {\n          clearTimeout(typingTimeoutRef.current);\n        }\n        socket.emit('stopTyping', {\n          roomId: currentRoom,\n          userId: currentUser.id\n        });\n      }\n    }\n  };\n\n  // Mark message as read\n  const markMessageAsRead = (messageId, roomId) => {\n    if (socket && isConnected) {\n      socket.emit('markAsRead', {\n        messageId,\n        roomId\n      });\n    }\n  };\n\n  // Dismiss notification\n  const dismissNotification = notificationId => {\n    setNotifications(prev => prev.filter(notif => notif.id !== notificationId));\n  };\n\n  // Clear all notifications\n  const clearAllNotifications = () => {\n    setNotifications([]);\n  };\n  const value = {\n    socket,\n    isConnected,\n    isReconnecting,\n    currentRoom,\n    roomUsers,\n    typingUsers,\n    notifications,\n    messageStatus,\n    sendMessage,\n    joinRoom,\n    leaveRoom,\n    sendTypingStatus,\n    markMessageAsRead,\n    dismissNotification,\n    clearAllNotifications\n  };\n  return /*#__PURE__*/_jsxDEV(SocketContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 327,\n    columnNumber: 5\n  }, this);\n}\n_s2(SocketProvider, \"8my1x7ouL2FqwCocgSLViFCRqeM=\", false, function () {\n  return [useAuth];\n});\n_c = SocketProvider;\nexport default SocketContext;\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","useCallback","useRef","io","useAuth","jsxDEV","_jsxDEV","SocketContext","useSocket","_s","SocketProvider","children","_s2","socket","setSocket","isConnected","setIsConnected","roomUsers","setRoomUsers","currentRoom","setCurrentRoom","reconnectAttempts","setReconnectAttempts","isReconnecting","setIsReconnecting","typingUsers","setTypingUsers","notifications","setNotifications","messageStatus","setMessageStatus","currentUser","typingTimeoutRef","maxReconnectAttempts","connectSocket","newSocket","process","env","REACT_APP_API_URL","path","namespace","reconnection","reconnectionAttempts","reconnectionDelay","reconnectionDelayMax","timeout","attemptReconnect","console","error","prev","on","log","emit","roomId","userId","id","username","name","email","messageData","Date","now","message","timestamp","messageId","data","users","some","user","filter","delivered","deliveredAt","read","readAt","current","clearTimeout","close","sendMessage","sent","sentAt","joinRoom","notif","leaveRoom","sendTypingStatus","isTyping","setTimeout","markMessageAsRead","dismissNotification","notificationId","clearAllNotifications","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/VRUSHANK/Desktop/Ecom Website/client/src/contexts/SocketContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';\r\nimport io from 'socket.io-client';\r\nimport { useAuth } from './AuthContext';\r\n\r\nconst SocketContext = createContext();\r\n\r\nexport function useSocket() {\r\n  return useContext(SocketContext);\r\n}\r\n\r\nexport function SocketProvider({ children }) {\r\n  const [socket, setSocket] = useState(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [roomUsers, setRoomUsers] = useState([]);\r\n  const [currentRoom, setCurrentRoom] = useState(null);\r\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\r\n  const [isReconnecting, setIsReconnecting] = useState(false);\r\n  const [typingUsers, setTypingUsers] = useState([]);\r\n  const [notifications, setNotifications] = useState([]);\r\n  const [messageStatus, setMessageStatus] = useState({});\r\n  const { currentUser } = useAuth();\r\n  \r\n  // Keep a ref for timeout to clear typing status\r\n  const typingTimeoutRef = useRef(null);\r\n  const maxReconnectAttempts = 5;\r\n  \r\n  // Create socket connection\r\n  const connectSocket = useCallback(() => {\r\n    if (!currentUser) return null;\r\n    \r\n    const newSocket = io(process.env.REACT_APP_API_URL || 'http://localhost:5000', {\r\n      path: '/socket.io',\r\n      namespace: '/chat',\r\n      reconnection: true,\r\n      reconnectionAttempts: maxReconnectAttempts,\r\n      reconnectionDelay: 1000,\r\n      reconnectionDelayMax: 5000,\r\n      timeout: 10000,\r\n    });\r\n    \r\n    return newSocket;\r\n  }, [currentUser]);\r\n  \r\n  // Handle reconnection logic\r\n  const attemptReconnect = useCallback(() => {\r\n    if (reconnectAttempts >= maxReconnectAttempts) {\r\n      console.error('Max reconnection attempts reached');\r\n      setIsReconnecting(false);\r\n      return;\r\n    }\r\n    \r\n    setIsReconnecting(true);\r\n    const newSocket = connectSocket();\r\n    \r\n    if (newSocket) {\r\n      setSocket(newSocket);\r\n      setReconnectAttempts(prev => prev + 1);\r\n    }\r\n  }, [connectSocket, reconnectAttempts, maxReconnectAttempts]);\r\n  \r\n  // Setup socket connection\r\n  useEffect(() => {\r\n    // Only connect if user is authenticated\r\n    if (currentUser) {\r\n      // Create socket connection\r\n      const newSocket = connectSocket();\r\n      \r\n      if (!newSocket) return;\r\n      \r\n      // Socket event listeners\r\n      newSocket.on('connect', () => {\r\n        console.log('Socket connected');\r\n        setIsConnected(true);\r\n        setIsReconnecting(false);\r\n        setReconnectAttempts(0);\r\n        \r\n        // Rejoin room if was previously in one\r\n        if (currentRoom) {\r\n          newSocket.emit('join', {\r\n            roomId: currentRoom,\r\n            userId: currentUser.id,\r\n            username: currentUser.name || currentUser.email\r\n          });\r\n        }\r\n      });\r\n      \r\n      newSocket.on('disconnect', () => {\r\n        console.log('Socket disconnected');\r\n        setIsConnected(false);\r\n        attemptReconnect();\r\n      });\r\n      \r\n      newSocket.on('connect_error', (error) => {\r\n        console.error('Socket connection error:', error);\r\n        setIsConnected(false);\r\n        attemptReconnect();\r\n      });\r\n\r\n      // Event listeners for chat functionality\r\n      newSocket.on('message', (messageData) => {\r\n        console.log('Message received:', messageData);\r\n        \r\n        // Add to notifications if not in current room\r\n        if (messageData.roomId !== currentRoom) {\r\n          setNotifications(prev => [...prev, {\r\n            id: Date.now(),\r\n            message: `New message from ${messageData.username} in room ${messageData.roomId}`,\r\n            roomId: messageData.roomId,\r\n            timestamp: new Date()\r\n          }]);\r\n        }\r\n        \r\n        // Acknowledge message receipt\r\n        newSocket.emit('messageReceived', {\r\n          messageId: messageData.id,\r\n          roomId: messageData.roomId\r\n        });\r\n      });\r\n\r\n      newSocket.on('userJoined', (data) => {\r\n        console.log('User joined:', data);\r\n      });\r\n\r\n      newSocket.on('userLeft', (data) => {\r\n        console.log('User left:', data);\r\n      });\r\n\r\n      newSocket.on('roomUsers', (data) => {\r\n        console.log('Users in room:', data);\r\n        setRoomUsers(data.users);\r\n      });\r\n      \r\n      // Typing indicator events\r\n      newSocket.on('userTyping', (data) => {\r\n        setTypingUsers(prev => {\r\n          if (!prev.some(user => user.id === data.userId)) {\r\n            return [...prev, { id: data.userId, username: data.username }];\r\n          }\r\n          return prev;\r\n        });\r\n      });\r\n      \r\n      newSocket.on('userStoppedTyping', (data) => {\r\n        setTypingUsers(prev => prev.filter(user => user.id !== data.userId));\r\n      });\r\n      \r\n      // Message status updates\r\n      newSocket.on('messageDelivered', (data) => {\r\n        setMessageStatus(prev => ({\r\n          ...prev,\r\n          [data.messageId]: { ...prev[data.messageId], delivered: true, deliveredAt: new Date() }\r\n        }));\r\n      });\r\n      \r\n      newSocket.on('messageRead', (data) => {\r\n        setMessageStatus(prev => ({\r\n          ...prev,\r\n          [data.messageId]: { ...prev[data.messageId], read: true, readAt: new Date() }\r\n        }));\r\n      });\r\n      \r\n      setSocket(newSocket);\r\n      \r\n      // Cleanup function\r\n      return () => {\r\n        if (currentRoom) {\r\n          newSocket.emit('leaveRoom', { roomId: currentRoom });\r\n        }\r\n        \r\n        // Clear any existing timeouts\r\n        if (typingTimeoutRef.current) {\r\n          clearTimeout(typingTimeoutRef.current);\r\n        }\r\n        \r\n        newSocket.close();\r\n      };\r\n    } else {\r\n      // If user logs out, disconnect socket\r\n      if (socket) {\r\n        if (currentRoom) {\r\n          socket.emit('leaveRoom', { roomId: currentRoom });\r\n        }\r\n        socket.close();\r\n        setSocket(null);\r\n        setIsConnected(false);\r\n        setCurrentRoom(null);\r\n        setRoomUsers([]);\r\n        setTypingUsers([]);\r\n        // Clear notifications and message status on logout\r\n        setNotifications([]);\r\n        setMessageStatus({});\r\n      }\r\n    }\r\n  }, [currentUser, connectSocket, attemptReconnect, currentRoom, socket]);\r\n  \r\n  // Functions to emit events\r\n  const sendMessage = (roomId, message) => {\r\n    if (socket && isConnected && currentUser) {\r\n      const messageId = `${Date.now()}-${currentUser.id}`;\r\n      \r\n      socket.emit('sendMessage', {\r\n        id: messageId,\r\n        roomId,\r\n        message,\r\n        userId: currentUser.id,\r\n        username: currentUser.name || currentUser.email\r\n      });\r\n      \r\n      // Initialize message status\r\n      setMessageStatus(prev => ({\r\n        ...prev,\r\n        [messageId]: { sent: true, sentAt: new Date() }\r\n      }));\r\n      \r\n      return messageId;\r\n    }\r\n    return null;\r\n  };\r\n  \r\n  const joinRoom = (roomId) => {\r\n    if (socket && isConnected && currentUser) {\r\n      // Leave current room if any\r\n      if (currentRoom && currentRoom !== roomId) {\r\n        socket.emit('leaveRoom', { roomId: currentRoom });\r\n      }\r\n      \r\n      // Join new room\r\n      socket.emit('join', {\r\n        roomId,\r\n        userId: currentUser.id,\r\n        username: currentUser.name || currentUser.email\r\n      });\r\n      \r\n      setCurrentRoom(roomId);\r\n      \r\n      // Clear notifications for this room\r\n      setNotifications(prev => prev.filter(notif => notif.roomId !== roomId));\r\n      \r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n  \r\n  const leaveRoom = () => {\r\n    if (socket && isConnected && currentRoom) {\r\n      socket.emit('leaveRoom', { roomId: currentRoom });\r\n      setCurrentRoom(null);\r\n      setRoomUsers([]);\r\n      setTypingUsers([]);\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n  \r\n  // Typing indicator\r\n  const sendTypingStatus = (isTyping) => {\r\n    if (socket && isConnected && currentUser && currentRoom) {\r\n      if (isTyping) {\r\n        socket.emit('typing', {\r\n          roomId: currentRoom,\r\n          userId: currentUser.id,\r\n          username: currentUser.name || currentUser.email\r\n        });\r\n        \r\n        // Clear existing timeout\r\n        if (typingTimeoutRef.current) {\r\n          clearTimeout(typingTimeoutRef.current);\r\n        }\r\n        \r\n        // Set timeout to automatically stop typing status after 3 seconds\r\n        typingTimeoutRef.current = setTimeout(() => {\r\n          socket.emit('stopTyping', {\r\n            roomId: currentRoom,\r\n            userId: currentUser.id\r\n          });\r\n        }, 3000);\r\n      } else {\r\n        // Clear timeout if exists\r\n        if (typingTimeoutRef.current) {\r\n          clearTimeout(typingTimeoutRef.current);\r\n        }\r\n        \r\n        socket.emit('stopTyping', {\r\n          roomId: currentRoom,\r\n          userId: currentUser.id\r\n        });\r\n      }\r\n    }\r\n  };\r\n  \r\n  // Mark message as read\r\n  const markMessageAsRead = (messageId, roomId) => {\r\n    if (socket && isConnected) {\r\n      socket.emit('markAsRead', { messageId, roomId });\r\n    }\r\n  };\r\n  \r\n  // Dismiss notification\r\n  const dismissNotification = (notificationId) => {\r\n    setNotifications(prev => prev.filter(notif => notif.id !== notificationId));\r\n  };\r\n  \r\n  // Clear all notifications\r\n  const clearAllNotifications = () => {\r\n    setNotifications([]);\r\n  };\r\n  \r\n  const value = {\r\n    socket,\r\n    isConnected,\r\n    isReconnecting,\r\n    currentRoom,\r\n    roomUsers,\r\n    typingUsers,\r\n    notifications,\r\n    messageStatus,\r\n    sendMessage,\r\n    joinRoom,\r\n    leaveRoom,\r\n    sendTypingStatus,\r\n    markMessageAsRead,\r\n    dismissNotification,\r\n    clearAllNotifications\r\n  };\r\n  \r\n  return (\r\n    <SocketContext.Provider value={value}>\r\n      {children}\r\n    </SocketContext.Provider>\r\n  );\r\n}\r\n\r\nexport default SocketContext; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}